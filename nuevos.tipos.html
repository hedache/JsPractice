<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nuevos tipos de datos en Js</title>
</head>
<body>
    <h1>Nuevos tipos de datos en javascript</h1>
    <script>

        // Symbol: es un tipo de dato privado, pora uso interno
        // permite crear identificadores unicos de referencia

        // se utiliza para crear propiedades privadas de los objs

        let id = Symbol("id");
        let id2 = Symbol("id2");

        console.log(id === id2);
        console.log(id, id2);
        console.log(typeof id, typeof id2);

        const NOMBRE = Symbol("nombre");
        const SALUDAR = Symbol("saludar");

        const persona = {
            [NOMBRE]: 'lol',
            edad: 54
        }

        console.log(persona);

        persona.NOMBRE = 'Hedache';
        console.log(persona);
        console.log(persona.NOMBRE);
        console.log(persona[NOMBRE]);

        persona[SALUDAR] = function (){
            console.log('Hola');
        }

        console.log(persona);
        persona[SALUDAR]();

        // aquí no aparece el Symbol porque es un propiedad privada
        for(let propiedad in persona) {
            console.log(propiedad);
            console.log(persona[propiedad]);
        }

        // ya que en el for in no muestra los Symbol, lo puedo traer y lo muestra en []
        console.log(Object.getOwnPropertySymbols(persona));

        // Symbol sirve para crear elementos privados dentro de un obj y que sus referencias van a ser únicas




        console.clear()

        // SET no guarda datos repetidos, excepto los obj, ya que cada obj hace referencia a un obj diferente.
        // parece ser un array, pero no
        // set es un obj especial que se comporta como obj
        
        const set = new Set([1,2,3,4,5,6,7,7,7,7,7, true, false, true, {}, {}, "hola", "HOla"]);
        console.log(set);
        console.log(set.size);

        const set2 = new Set();
        set2.add(1);
        set2.add(2);
        set2.add(2);
        set2.add(2);
        set2.add(3);
        set2.add(true);
        set2.add(false);
        set2.add(true);
        set2.add({});

        console.log(set2);
        console.log(set2.size);
        // console.clear();

        for(l of set) {
            console.log(l);
        }

        set2.forEach(ll => console.log(ll));

        // con set no sé accede a la posición como un array, toca por así decirlo como convertirlo y ahí si

        let arr = Array.from(set);
        console.log(arr);

        // set es una colección de datos únicos
        set.delete("HOla")


        // comprueba si el valor existe en la colección de datos, retorna true o false.
        console.log(set.has("hola"));

        // limpiar un set
        set.clear();
        console.log(set);

        console.clear();

        // MAP: son obj que nos sirven para almacenar conjuntos de valores asociados a manera de obj, es muy parecido a un obj primitivo
        // Es un obj iterador
        // el map trabaja muy similar a los set y get

        let mapa = new Map();
        mapa.set('nombre', 'hedache');
        mapa.set('apellido', 'Mircha');
        mapa.set('edad', 20);

        console.log(mapa);
        console.log(mapa.size);

        // comprobar si existe una llave
        console.log(mapa.has('correo'));
        console.log(mapa.has('nombre'));
        console.log(mapa.get('nombre'));
        mapa.set('nombre', 'Hedache lol')
        console.log(mapa);
        console.log(mapa.get('nombre'));
        mapa.delete('apellido');


        mapa.set(19, 'diecinueve');
        mapa.set(false, 'falso');
        mapa.set({}, {})


        console.log(mapa);

        // destructuración

        for(let [key, value] of mapa) {
            console.log(`La llave: ${key}, Valor: ${value}`);
        }

        const mapa2 = new Map([
            ['nombre', 'lol'],
            ['edad', 7],
            ['animal', 'perro'],
            [null, 'nulo']
        ])

        console.log(mapa2);
        

        const llavesMapa2 = [...mapa2.keys()];
        const valoresMapa2 = [...mapa2.keys()];

        console.log(llavesMapa2);
        console.log(valoresMapa2);


        console.clear();


        // WEAKSETS y WEAKMAPS: mapas débiles y conjuntos débiles
        // solo pueden almacenar referencias débiles

        const ws = new WeakSet();

        let valor1 = {'valor1': 1}
        let valor2 = {'valor2': 2}
        let valor3 = {'valor3': 3}

        ws.add(valor1);
        ws.add(valor2);
        console.log(ws);

        console.log(ws.has(valor1));
        console.log(ws.has(valor3));

        ws.delete(valor2);
        console.log(ws);

        ws.add(valor2);
        ws.add(valor3);
        console.log(ws);

        // setInterval(() => console.log(ws), 1000);

        // setTimeout(() => {
        //     valor1 = null;
        //     valor2 = null;
        //     valor3 = null;
        // }, 5000)


        console.clear();

        const wm = new WeakMap();
        let llave1 = {};
        let llave2 = {};
        let llave3 = {};

        wm.set(llave1, 1)
        wm.set(llave2, 2)
        // wm.set(llave3, 3)
        console.log(wm);

        console.log(wm.has(llave1));
        console.log(wm.has(llave3));

        console.log(wm.get(llave1));
        console.log(wm.get(llave2));
        console.log(wm.get(llave3));

        wm.delete(llave2)
        console.log(wm);

        wm.set(llave2, 3);
        wm.set(llave3, 3);
        console.log(wm);

        // cuando se nulifican las referencias de wm ws, se van a eliminar automáticamente, y esto mejora el rendimiento de nuestra aplicación

        // variables de estado si las he declarao en vue, react, angular y quiero manejar aquí en vanilla js, sería de la sgt manera
        // obj -> wm
        // [] -> ws

        setInterval(() => console.log(wm), 1000);

        setTimeout(() => {
            llave1 = null;
            llave2 = null;
            llave3 = null;
        }, 5000)




























    </script>
</body>
</html>