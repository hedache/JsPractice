<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Nuevos tipos de datos en Js</title>
    </head>
    <body>
        <h1>Nuevos tipos de datos en javascript</h1>
        <script>

        // Symbol: es un tipo de dato privado, pora uso interno
        // permite crear identificadores unicos de referencia

        // se utiliza para crear propiedades privadas de los objs

        let id = Symbol("id");
        let id2 = Symbol("id2");

        console.log(id === id2);
        console.log(id, id2);
        console.log(typeof id, typeof id2);

        const NOMBRE = Symbol("nombre");
        const SALUDAR = Symbol("saludar");

        const persona = {
            [NOMBRE]: 'lol',
            edad: 54
        }

        console.log(persona);

        persona.NOMBRE = 'Hedache';
        console.log(persona);
        console.log(persona.NOMBRE);
        console.log(persona[NOMBRE]);

        persona[SALUDAR] = function (){
            console.log('Hola');
        }

        console.log(persona);
        persona[SALUDAR]();

        // aquí no aparece el Symbol porque es un propiedad privada
        for(let propiedad in persona) {
            console.log(propiedad);
            console.log(persona[propiedad]);
        }

        // ya que en el for in no muestra los Symbol, lo puedo traer y lo muestra en []
        console.log(Object.getOwnPropertySymbols(persona));

        // Symbol sirve para crear elementos privados dentro de un obj y que sus referencias van a ser únicas




        console.clear()

        // SET no guarda datos repetidos, excepto los obj, ya que cada obj hace referencia a un obj diferente.
        // parece ser un array, pero no
        // set es un obj especial que se comporta como obj
        
        const set = new Set([1,2,3,4,5,6,7,7,7,7,7, true, false, true, {}, {}, "hola", "HOla"]);
        console.log(set);
        console.log(set.size);

        const set2 = new Set();
        set2.add(1);
        set2.add(2);
        set2.add(2);
        set2.add(2);
        set2.add(3);
        set2.add(true);
        set2.add(false);
        set2.add(true);
        set2.add({});

        console.log(set2);
        console.log(set2.size);
        // console.clear();

        for(l of set) {
            console.log(l);
        }

        set2.forEach(ll => console.log(ll));

        // con set no sé accede a la posición como un array, toca por así decirlo como convertirlo y ahí si

        let arr = Array.from(set);
        console.log(arr);

        // set es una colección de datos únicos
        set.delete("HOla")


        // comprueba si el valor existe en la colección de datos, retorna true o false.
        console.log(set.has("hola"));

        // limpiar un set
        set.clear();
        console.log(set);

        console.clear();

        // MAP: son obj que nos sirven para almacenar conjuntos de valores asociados a manera de obj, es muy parecido a un obj primitivo
        // Es un obj iterador
        // el map trabaja muy similar a los set y get

        let mapa = new Map();
        mapa.set('nombre', 'hedache');
        mapa.set('apellido', 'Mircha');
        mapa.set('edad', 20);

        console.log(mapa);
        console.log(mapa.size);

        // comprobar si existe una llave
        console.log(mapa.has('correo'));
        console.log(mapa.has('nombre'));
        console.log(mapa.get('nombre'));
        mapa.set('nombre', 'Hedache lol')
        console.log(mapa);
        console.log(mapa.get('nombre'));
        mapa.delete('apellido');


        mapa.set(19, 'diecinueve');
        mapa.set(false, 'falso');
        mapa.set({}, {})


        console.log(mapa);

        // destructuración

        for(let [key, value] of mapa) {
            console.log(`La llave: ${key}, Valor: ${value}`);
        }

        const mapa2 = new Map([
            ['nombre', 'lol'],
            ['edad', 7],
            ['animal', 'perro'],
            [null, 'nulo']
        ])

        console.log(mapa2);
        

        const llavesMapa2 = [...mapa2.keys()];
        const valoresMapa2 = [...mapa2.keys()];

        console.log(llavesMapa2);
        console.log(valoresMapa2);


        console.clear();


        // WEAKSETS y WEAKMAPS: mapas débiles y conjuntos débiles
        // solo pueden almacenar referencias débiles

        const ws = new WeakSet();

        let valor1 = {'valor1': 1}
        let valor2 = {'valor2': 2}
        let valor3 = {'valor3': 3}

        ws.add(valor1);
        ws.add(valor2);
        console.log(ws);

        console.log(ws.has(valor1));
        console.log(ws.has(valor3));

        ws.delete(valor2);
        console.log(ws);

        ws.add(valor2);
        ws.add(valor3);
        console.log(ws);

        // setInterval(() => console.log(ws), 1000);

        // setTimeout(() => {
        //     valor1 = null;
        //     valor2 = null;
        //     valor3 = null;
        // }, 5000)


        console.clear();

        const wm = new WeakMap();
        let llave1 = {};
        let llave2 = {};
        let llave3 = {};

        wm.set(llave1, 1)
        wm.set(llave2, 2)
        // wm.set(llave3, 3)
        console.log(wm);

        console.log(wm.has(llave1));
        console.log(wm.has(llave3));

        console.log(wm.get(llave1));
        console.log(wm.get(llave2));
        console.log(wm.get(llave3));

        wm.delete(llave2)
        console.log(wm);

        wm.set(llave2, 3);
        wm.set(llave3, 3);
        console.log(wm);

        // cuando se nulifican las referencias de wm ws, se van a eliminar automáticamente, y esto mejora el rendimiento de nuestra aplicación

        // variables de estado si las he declarao en vue, react, angular y quiero manejar aquí en vanilla js, sería de la sgt manera
        // obj -> wm
        // [] -> ws

        // setInterval(() => console.log(wm), 1000);

        // setTimeout(() => {
        //     console.log('hola');
        //     llave1 = null;
        //     llave2 = null;
        //     llave3 = null;
        // }, 5000)

        console.clear();


        // ITERABLES & ITERATORS

        // const iterable = [1,2,3,4,5]
        // const iterable = "Hola mundo"
        // const iterable = new Set([1,2,3,4,5]);
        const iterable = new Map([["nombre", "lol"], ["edad", 11]]);
        

        // Accedemos al iterados del iterable
        const iterador = iterable[Symbol.iterator]();

        console.log(iterable);
        console.log(iterador);
        // console.log(iterador.next());
        // console.log(iterador.next());
        // console.log(iterador.next());
        // console.log(iterador.next());
        // console.log(iterador.next());
        // console.log(iterador.next());

        let next = iterador.next();

        while(!next.done){
            console.log(next.value);
            next = iterador.next();
        }


        console.clear();

        // GENERATORS

        // el * le indica a js que es un generador
        // el yield cumple la función de  un return en un generador
        function* iterable2() {
            yield "hola";
            console.log('Hola Consola');
            yield 'hola 2';
            console.log('seguimos con mas instrucciones de nuestro código');
            yield 'hola 3';
            yield 'hola 4';
        }


        let iteradoss = iterable2();
        // console.log(iteradoss.next());
        // console.log(iteradoss.next());
        // console.log(iteradoss.next());
        // console.log(iteradoss.next());

        for(y of iteradoss){
            console.log(y);
            console.log('*******');
        }

        const arr22 = [...    iterable2()]
        console.log(arr22);

        const lo = [1,2,3,3,3,3,4,5,6,7,]
        console.log('lo', lo);
        console.log([...new Set(lo)]);

        function square(valor){
            setTimeout(() => {
                return console.log({valor, result: valor * valor});
            }, Math.random() * 1000)


            // return {
            //     valor,
            //     result: valor * valor
            // }
        }

        function* generador() {
            console.log('Inicia generados');
            yield square(0);
            yield square(1);
            yield square(2);
            yield square(3);
            yield square(4);
            yield square(5);
            console.log('Fin generados');
        }

        let gen = generador();

        // for(let r of gen){
        //     console.log(r);
        // }


        console.clear();

        // PROXIES: hace una vínculación entre el objeto original y el obj copia, y con su handler 
        // podemos hacer validaciones antes de su asignación

        
        const persona3 = {
            nombre: '',
            apellido: '',
            edad: 0
        }

        const manejador = {
            set(obj, prop, valor) {

                if(Object.keys(obj).indexOf(prop) === -1 ) {
                    return console.error(`La propiedad "${prop}" no existe en el objeto persona`);
                }

                if (
                    (prop === 'nombre' || prop === 'apellido') && !(/^[A-Za-zÑñÁáÉéÍíÓóÚúÜü\s]+$/g.test(valor))
                ) {
                    return console.error(`La propiedad "${prop}" solo acepta letras y espacios en blanco`)
                }







                obj[prop] = valor;
            }
        }

        const jon = new Proxy(persona3, manejador);
        jon.nombre = 'hedache 11';
        jon.apellido = 'lol';
        jon.edad = 77;
        jon.twitter = '@hedache';

        console.log(jon);
        console.log(persona3);
























    </script>
    </body>
</html>